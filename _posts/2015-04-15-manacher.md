---
layout: post
title: "manacher算法的理解"
description: "manacher算法可以线性时间复杂度的情况下判断字符串中最大回文字符串长度"
category:
tags: []
---
{% include JB/setup %}     
> 请尊重原创，转载请注


### 题目

***回文字符串***: 就是正向读和逆向读都是一样的字符串。例如：12321，aabb，aacbb

***回文字符串特点***：aabb是双数的，12321这种是单数的

> 给定一个字符串“aaaba”，请求出这个字符串中最大回文字符串的长度？

### 常规解法

* 求出给定字符串的所有字串，然后挨个判断字串是不是回文字符串。时间复杂度O(n^3)
* 循环字符串的每个字符，然后按照奇偶情况分别判断其最大回文串长度。时间复杂度O(n^2)

（*注：以上解法本人没有实验，如果有朋友感兴趣可以尝试*）

### manacher算法原理

为什么说这个算法，很简单，因为时间复杂度比前两个低！！（实际请看代码）   
另一个原因就是它解决了第二种算法要判断奇偶。     
**原始字符串假定为S，图1中第一行字符串假定为串T,第二行假定为Len。**

**针对步骤**

1. **解决奇偶：**给定的字符串中每个字符两边加上一个特殊字符，例如：＃（见图1）原字符串长度不论奇偶，都变成奇数长度，最后原字符串变为T。
2. **正常处理：**现在对新的字符串T按照常规解法中的第二种解法，循环分析每个字符拥有的最大回文字符长度是多少？**每次循环都要保存最大的回文长度（mx）和其对应的中心点的位置（id）**
3. **特殊处理：**如果当前处理的字符T[i]距离T[id]的距离小于T[id]的回文字符串长度mx（这是目前为止最大的回文），按照对称来讲，就会有一个点j，它和i处于id点的两侧，并且互相对程。（好绕口，呵呵）***通俗讲，就是说有可能 i 这个点不用按照第二步那样一个个遍历旁边的字符去求回文长度，它有可能直接用 j（已经算好了回文长度）的回文长度！！*** 这里很关键～～

> 如果 i 点通过对程特性，能够获得一个最基本的回文长度，那就可以在此之上继续循环判断。
> ***
> 如果 i 不能利用对称特性，那只好老老实实的按照步骤2中所讲，对身边的字符串一个个进行遍历，最终得到回文长度

**一些公式**


`mx + id > i` T[i]被包含在T[id]的最大回文长度（mx）内，则可以利用对称特性。否则Len[i]=1（图2）     
`2id-i`  这个公式可以算出j的位置。原理是：`id-(i-id)` （图2）    
`T[i]-1` 对T每个字符的回文长度结果都会保存在对应的Len串中，T[i]的回文长度保存在Len[i]中，而Len[i]-1就是对应的原始字符串中S[i]的回文长度。**因此，把T的每个值求出来之后，就知道原始串S的最大回文长度！**

### 图解原理
<img src="https://raw.githubusercontent.com/arkulo56/thought/master/fotosay/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%85%8D%E5%9B%BE.png" width="600" />

图2和图3是mx+id>1的两种不同情况：

* 图2可以发现，j的回文长度向左侧延伸但不超过左侧的mx,i的回文长度大于等于j的回文长度
* 图3可以发现，j的回文长度想做延伸超过了左侧mx,可是i的右侧超过mx的字符还没有被遍历过，因此i的回文长度只能大于等于mx－i


### 代码


	<?php
	function processOne($str)
	{
		$res = "";
		for($i=0;$i<strlen($str);$i++)
		{
			$res .= $str[$i]."#";
		}
		return "#".$res;
	}

	function manacher($str)
	{
		$Len = array();
		$mx = 0;
		$id = 0;
		for($i=0;$i<strlen($str);$i++)
		{
			if($mx+$id>$i)
			{
				$Len[$i] = min($Len[2*$id-$i],$mx-$i);
			}else
			{
				$Len[$i] = 1;
			}
			while($i-$Len[$i]>=0 && $i+$Len[$i]<strlen($str) && $str[$i-$Len[$i]] == $str[$i+$Len[$i]])
			{
				++$Len[$i];
			}
			if($Len[$i]>$mx)
			{
				$mx = $Len[$i];
				$id = $i;
			}
			echo $str[$i],"----",$Len[$i],"\n\r";
		}
	}

	$S = "aaaba";


	$T = processOne($S);
	manacher($T);

	?>

